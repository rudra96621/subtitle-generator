[
  {
    "projectId": "a4172931-bb4c-4e43-b2cf-c045895728b2",
    "testId": "4b5476a7-1b9c-4005-98b0-b6129e106bdc",
    "userId": "f4783428-d071-70f8-dd6c-d4ad731b78ab",
    "title": "TC001-user registration with valid data",
    "description": "Test the user registration endpoint /signup with valid full_name, email, username, and password to ensure successful account creation and proper response.",
    "code": "import requests\nimport uuid\nimport traceback\n\nBASE_URL = \"http://localhost:8501\"\nSIGNUP_ENDPOINT = f\"{BASE_URL}/signup\"\nDELETE_USER_ENDPOINT_TEMPLATE = f\"{BASE_URL}/admin/users/{{username}}\"\n\ndef test_user_registration_with_valid_data():\n    # Generate unique user data for the test to avoid conflicts and ensure idempotency\n    unique_suffix = str(uuid.uuid4())[:8]\n    test_user = {\n        \"full_name\": f\"Test User {unique_suffix}\",\n        \"email\": f\"testuser{unique_suffix}@example.com\",\n        \"username\": f\"testuser{unique_suffix}\",\n        \"password\": \"StrongPass!2025\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    created = False\n    try:\n        # Perform the signup request with valid user data\n        response = requests.post(\n            SIGNUP_ENDPOINT,\n            json=test_user,\n            headers=headers,\n            timeout=30\n        )\n        # Assert HTTP status code for successful creation (commonly 201 or 200)\n        assert response.status_code in (200, 201), f\"Unexpected status code: {response.status_code}, Response: {response.text}\"\n\n        # Validate response content structure: expect JSON with success confirmation or user data (cannot assume exact schema but check basics)\n        try:\n            data = response.json()\n        except Exception as e:\n            assert False, f\"Response not valid JSON: {response.text}\"\n\n        # Basic validations on returned JSON fields for robustness\n        assert isinstance(data, dict), f\"Expected response body to be dict, got {type(data)}\"\n\n        # Check if there is an indication of success or user info\n        # Accept keys like 'message', 'user', 'username', 'id', etc.\n        keys = data.keys()\n        assert any(k in keys for k in [\"username\", \"user\", \"message\", \"id\"]), \"Response JSON missing expected keys.\"\n\n        # Security checks - password or sensitive info must NOT be returned\n        sensitive_fields = ['password', 'pwd', 'pass']\n        for field in sensitive_fields:\n            assert field not in data, f\"Sensitive field {field} found in response\"\n\n        created = True\n\n        # Additional edge test: ensure returned username/email matches sent\n        if \"username\" in data:\n            assert data[\"username\"] == test_user[\"username\"], \"Returned username does not match sent username\"\n        elif \"user\" in data and isinstance(data[\"user\"], dict):\n            assert data[\"user\"].get(\"username\") == test_user[\"username\"], \"Returned user.username does not match sent username\"\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {str(e)}\"\n    except AssertionError:\n        # Reraise for test framework reporting\n        raise\n    except Exception:\n        traceback.print_exc()\n        assert False, \"Unexpected error during test execution\"\n\n    finally:\n        # Cleanup: Delete the created user to keep testing environment clean\n        if created:\n            try:\n                delete_url = DELETE_USER_ENDPOINT_TEMPLATE.format(username=test_user[\"username\"])\n                del_response = requests.delete(delete_url, timeout=30)\n                # Accept 200 or 204 as successful deletion responses\n                assert del_response.status_code in (200, 204), f\"User deletion failed with status {del_response.status_code}\"\n            except Exception:\n                # Log cleanup failure but do not fail test because registration succeeded\n                traceback.print_exc()\n\ntest_user_registration_with_valid_data()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 81, in <module>\n  File \"<string>\", line 31, in test_user_registration_with_valid_data\nAssertionError: Unexpected status code: 403, Response: <html><title>403: Forbidden</title><body>403: Forbidden</body></html>\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T15:23:09.155Z",
    "modified": "2025-09-06T15:24:05.836Z"
  },
  {
    "projectId": "a4172931-bb4c-4e43-b2cf-c045895728b2",
    "testId": "f453020e-8d15-49b7-bd7a-4acb315c4c0b",
    "userId": "f4783428-d071-70f8-dd6c-d4ad731b78ab",
    "title": "TC002-user login with correct credentials",
    "description": "Test the user login endpoint /login with valid username and password to verify successful authentication and session creation.",
    "code": "import requests\nimport time\nimport random\nimport string\n\nBASE_URL = \"http://localhost:8501\"\nTIMEOUT = 30\n\ndef generate_random_user():\n    suffix = ''.join(random.choices(string.ascii_letters + string.digits, k=8))\n    return {\n        \"full_name\": f\"Test User {suffix}\",\n        \"email\": f\"testuser{suffix}@example.com\",\n        \"username\": f\"testuser{suffix}\",\n        \"password\": \"StrongP@ssw0rd!\"\n    }\n\ndef test_user_login_with_correct_credentials():\n    session = requests.Session()\n    headers = {\"Content-Type\": \"application/json\"}\n    user = generate_random_user()\n\n    # Register new user for login test\n    signup_url = f\"{BASE_URL}/signup\"\n    login_url = f\"{BASE_URL}/login\"\n    delete_user_url = f\"{BASE_URL}/admin/users/{user['username']}\"\n    try:\n        # Create user\n        resp_signup = session.post(signup_url, json=user, headers=headers, timeout=TIMEOUT)\n        assert resp_signup.status_code == 201 or resp_signup.status_code == 200, f\"User signup failed: {resp_signup.text}\"\n\n        # Wait briefly to ensure user is ready for login\n        time.sleep(0.5)\n\n        # Test login with correct credentials\n        login_payload = {\n            \"username\": user[\"username\"],\n            \"password\": user[\"password\"]\n        }\n        resp_login = session.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n\n        # Validate response code and body structure\n        assert resp_login.status_code == 200, f\"Login failed with status code {resp_login.status_code}: {resp_login.text}\"\n        json_resp = resp_login.json()\n        assert \"token\" in json_resp or \"session_id\" in json_resp or \"message\" in json_resp, \"Login response missing expected fields\"\n\n        # Validate that the token/session is non-empty if present\n        if \"token\" in json_resp:\n            assert isinstance(json_resp[\"token\"], str) and json_resp[\"token\"], \"Empty token received\"\n        if \"session_id\" in json_resp:\n            assert isinstance(json_resp[\"session_id\"], str) and json_resp[\"session_id\"], \"Empty session_id received\"\n\n        # Additional edge case: login with extra fields ignored by the API\n        extended_payload = {\n            \"username\": user[\"username\"],\n            \"password\": user[\"password\"],\n            \"unexpected_field\": \"unexpected_value\"\n        }\n        resp_ext = session.post(login_url, json=extended_payload, headers=headers, timeout=TIMEOUT)\n        assert resp_ext.status_code == 200, \"Login failed with unexpected extra fields\"\n        resp_ext_json = resp_ext.json()\n        assert \"token\" in resp_ext_json or \"session_id\" in resp_ext_json, \"Login with extra fields missing token/session_id\"\n\n        # Security edge case: login with password having SQL injection pattern\n        sql_injection_payload = {\n            \"username\": user[\"username\"],\n            \"password\": \"' OR '1'='1\"\n        }\n        resp_sql = session.post(login_url, json=sql_injection_payload, headers=headers, timeout=TIMEOUT)\n        assert resp_sql.status_code in (400,401), \"Login should fail on SQL injection attempt\"\n\n        # Performance check: time taken for login should be reasonable (<5 seconds)\n        start_perf = time.time()\n        resp_perf = session.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n        elapsed = time.time() - start_perf\n        assert elapsed < 5, f\"Login took too long: {elapsed}s\"\n\n    finally:\n        # Cleanup: delete the created user (assuming admin endpoint available for test cleanup)\n        try:\n            resp_del = session.delete(delete_user_url, headers=headers, timeout=TIMEOUT)\n            # Accept both 200 OK and 204 No Content as success\n            if resp_del.status_code not in (200, 204, 404):\n                print(f\"Warning: unexpected status on user delete {resp_del.status_code}: {resp_del.text}\")\n        except Exception as e:\n            print(f\"Exception during cleanup user delete: {e}\")\n\ntest_user_login_with_correct_credentials()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 88, in <module>\n  File \"<string>\", line 30, in test_user_login_with_correct_credentials\nAssertionError: User signup failed: <html><title>403: Forbidden</title><body>403: Forbidden</body></html>\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T15:23:09.161Z",
    "modified": "2025-09-06T15:24:05.834Z"
  },
  {
    "projectId": "a4172931-bb4c-4e43-b2cf-c045895728b2",
    "testId": "e9f2f4ac-b172-461a-90e0-bb8394a9857e",
    "userId": "f4783428-d071-70f8-dd6c-d4ad731b78ab",
    "title": "TC003-password reset with matching new passwords",
    "description": "Test the password reset endpoint /reset_password by providing username, new_password, and confirm_password fields with matching passwords to ensure password update is successful.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8501\"\nTIMEOUT = 30\n\ndef test_password_reset_with_matching_new_passwords():\n    # Step 1: Create a test user to perform password reset\n    signup_url = f\"{BASE_URL}/signup\"\n    login_url = f\"{BASE_URL}/login\"\n    reset_password_url = f\"{BASE_URL}/reset_password\"\n\n    test_username = f\"testuser_{uuid.uuid4().hex[:8]}\"\n    original_password = \"OrigPass!1234\"\n    new_password = \"NewPass!5678\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Register user\n    signup_payload = {\n        \"full_name\": \"Test User\",\n        \"email\": f\"{test_username}@example.com\",\n        \"username\": test_username,\n        \"password\": original_password\n    }\n    try:\n        signup_resp = requests.post(signup_url, json=signup_payload, headers=headers, timeout=TIMEOUT)\n        assert signup_resp.status_code == 201 or signup_resp.status_code == 200, f\"Signup failed: {signup_resp.status_code} {signup_resp.text}\"\n\n        # Step 2: Password reset with matching new_password and confirm_password\n        reset_payload = {\n            \"username\": test_username,\n            \"new_password\": new_password,\n            \"confirm_password\": new_password\n        }\n        reset_resp = requests.post(reset_password_url, json=reset_payload, headers=headers, timeout=TIMEOUT)\n        assert reset_resp.status_code == 200, f\"Password reset failed with status {reset_resp.status_code}: {reset_resp.text}\"\n        reset_json = reset_resp.json()\n        # Expect some success indication, either a message or a success flag\n        assert (\"success\" in reset_json and reset_json[\"success\"] is True) or (\"message\" in reset_json), \"Password reset response missing success indication\"\n\n        # Step 3: Try logging in with the new password to verify password updated\n        login_payload = {\n            \"username\": test_username,\n            \"password\": new_password\n        }\n        login_resp = requests.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login after password reset failed: {login_resp.status_code} {login_resp.text}\"\n        # Expect token or success message\n        login_json = login_resp.json()\n        assert \"token\" in login_json or \"success\" in login_json, \"Login response missing token or success indication\"\n\n        # Additional security checks: attempting password reset with blank/new_password edge case\n        bad_payload = {\n            \"username\": test_username,\n            \"new_password\": \"\",\n            \"confirm_password\": \"\"\n        }\n        bad_resp = requests.post(reset_password_url, json=bad_payload, headers=headers, timeout=TIMEOUT)\n        assert bad_resp.status_code == 400 or bad_resp.status_code == 422, \"Expected error status code for empty passwords\"\n        bad_json = bad_resp.json()\n        assert \"error\" in bad_json or \"message\" in bad_json, \"Error response missing error message for blank passwords\"\n        \n        # Trying mismatched new_password and confirm_password\n        mismatch_payload = {\n            \"username\": test_username,\n            \"new_password\": \"password1\",\n            \"confirm_password\": \"password2\"\n        }\n        mismatch_resp = requests.post(reset_password_url, json=mismatch_payload, headers=headers, timeout=TIMEOUT)\n        assert mismatch_resp.status_code == 400 or mismatch_resp.status_code == 422, \"Expected error status for mismatched passwords\"\n        mismatch_json = mismatch_resp.json()\n        assert \"error\" in mismatch_json or \"message\" in mismatch_json, \"Error response missing error message for mismatched passwords\"\n\n    finally:\n        # Clean up: delete the test user if an admin endpoint or DB operation is available\n        # Attempt to delete user via admin panel or database operation\n        del_user_url = f\"{BASE_URL}/admin/users/{test_username}\"\n        try:\n            del_resp = requests.delete(del_user_url, timeout=TIMEOUT)\n            # Accept 200 or 204 as success, 404 means probably already deleted\n            assert del_resp.status_code in (200, 204, 404), f\"Failed to delete test user: {del_resp.status_code} {del_resp.text}\"\n        except Exception:\n            pass  # Best effort cleanup\n\ntest_password_reset_with_matching_new_passwords()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 86, in <module>\n  File \"<string>\", line 28, in test_password_reset_with_matching_new_passwords\nAssertionError: Signup failed: 403 <html><title>403: Forbidden</title><body>403: Forbidden</body></html>\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T15:23:09.166Z",
    "modified": "2025-09-06T15:24:05.838Z"
  },
  {
    "projectId": "a4172931-bb4c-4e43-b2cf-c045895728b2",
    "testId": "d581c7b9-8dd8-47d9-87fa-285c994bcab7",
    "userId": "f4783428-d071-70f8-dd6c-d4ad731b78ab",
    "title": "TC004-upload video audio file with supported format",
    "description": "Test the file upload endpoint /upload by uploading a valid video or audio file in supported formats to verify successful file storage and response.",
    "code": "import requests\nimport os\nimport io\n\nBASE_URL = \"http://localhost:8501\"\nUPLOAD_ENDPOINT = f\"{BASE_URL}/upload\"\nTIMEOUT = 30\n\n# Example supported video/audio formats (minimal to test with)\nSUPPORTED_EXTENSIONS = [\n    \".mp4\",  # video\n    \".mp3\",  # audio\n    \".wav\",\n    \".m4a\",\n    \".mov\",\n    \".aac\"\n]\n\n# Minimal valid dummy content generator for audio/video files\ndef generate_dummy_file_content(extension: str) -> bytes:\n    # Minimal headers or bytes to simulate a valid audio/video file for upload\n    # This is a simple heuristic: some formats start with certain bytes\n    if extension == \".mp4\" or extension == \".mov\":\n        # MP4/QuickTime file header: ftyp\n        return b\"\\x00\\x00\\x00\\x18ftypmp42\\x00\\x00\\x00\\x00mp42mp41isom\"\n    elif extension == \".mp3\":\n        # MP3 frame sync bytes\n        return b\"\\xff\\xfb\\x90\\x64\" + b\"\\x00\" * 1000\n    elif extension == \".wav\":\n        # WAV header \"RIFF\" chunk descriptor\n        return b\"RIFF\" + b\"\\x00\" * 1000\n    elif extension == \".m4a\":\n        # Similar to mp4 ftyp box\n        return b\"\\x00\\x00\\x00\\x18ftypM4A \" + b\"\\x00\" * 1000\n    elif extension == \".aac\":\n        # ADTS header start with 0xFFF\n        return b\"\\xff\\xf1\" + b\"\\x00\" * 1000\n    else:\n        # Default dummy content\n        return b\"dummydata\" * 100\n\ndef test_upload_video_audio_file_with_supported_format():\n    # Try all supported formats to comprehensively validate the endpoint behavior with different supported files\n    for ext in SUPPORTED_EXTENSIONS:\n        file_content = generate_dummy_file_content(ext)\n        file_name = f\"testfile{ext}\"\n        files = {\n            'file': (file_name, io.BytesIO(file_content), 'application/octet-stream')\n        }\n        headers = {}\n        response = None\n        try:\n            # Upload the file\n            response = requests.post(UPLOAD_ENDPOINT, files=files, headers=headers, timeout=TIMEOUT)\n            # Validate status code is success 2xx (preferably 200 or 201)\n            assert response.status_code in (200, 201), f\"Unexpected status code for {file_name}: {response.status_code}\"\n\n            # Validate content type is JSON or expected type\n            content_type = response.headers.get('Content-Type', '')\n            assert 'application/json' in content_type, f\"Response content type unexpected for {file_name}: {content_type}\"\n\n            # Validate returned JSON has expected structure indicating success and file info\n            json_resp = response.json()\n            # Assert at least a success indicator and stored filename or file id\n            assert 'success' in json_resp and json_resp['success'] is True, f\"Upload failed for {file_name}\"\n            # Assuming an 'file_id' or 'filename' is returned for reference\n            assert ('file_id' in json_resp or 'filename' in json_resp), f\"No file identifier returned for {file_name}\"\n\n            # Additional edge case: check size reported, content hashes, or warnings if any\n            if 'size' in json_resp:\n                assert isinstance(json_resp['size'], int) and json_resp['size'] > 0, \"Invalid size returned\"\n\n        except (requests.RequestException, AssertionError, ValueError) as e:\n            raise AssertionError(f\"Failed upload test for extension {ext}: {str(e)}\") from e\n\n\ntest_upload_video_audio_file_with_supported_format()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 56, in test_upload_video_audio_file_with_supported_format\nAssertionError: Unexpected status code for testfile.mp4: 403\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 77, in <module>\n  File \"<string>\", line 74, in test_upload_video_audio_file_with_supported_format\nAssertionError: Failed upload test for extension .mp4: Unexpected status code for testfile.mp4: 403\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T15:23:09.171Z",
    "modified": "2025-09-06T15:24:05.823Z"
  },
  {
    "projectId": "a4172931-bb4c-4e43-b2cf-c045895728b2",
    "testId": "94205f90-f882-472b-ba4a-28cc3d72c5bb",
    "userId": "f4783428-d071-70f8-dd6c-d4ad731b78ab",
    "title": "TC005-process video audio for subtitle generation",
    "description": "Test the /process endpoint by submitting spoken_lang, target_lang, model_size, and device parameters to verify correct transcription, translation, and subtitle generation workflow.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8501\"\nTIMEOUT = 30\n\ndef test_process_video_audio_for_subtitle_generation():\n    # Step 1: Authenticate user to call /process endpoint (create user & login)\n    session = requests.Session()\n    user_data = {\n        \"full_name\": \"Test User TC005\",\n        \"email\": \"testuser_tc005@example.com\",\n        \"username\": \"testuser_tc005\",\n        \"password\": \"StrongPass!234\"\n    }\n    try:\n        # Register user\n        resp_signup = session.post(\n            f\"{BASE_URL}/signup\",\n            json={\n                \"full_name\": user_data[\"full_name\"],\n                \"email\": user_data[\"email\"],\n                \"username\": user_data[\"username\"],\n                \"password\": user_data[\"password\"]\n            },\n            timeout=TIMEOUT\n        )\n        assert resp_signup.status_code == 201 or resp_signup.status_code == 200, f\"Signup failed: {resp_signup.text}\"\n\n        # Login user\n        resp_login = session.post(\n            f\"{BASE_URL}/login\",\n            json={\n                \"username\": user_data[\"username\"],\n                \"password\": user_data[\"password\"]\n            },\n            timeout=TIMEOUT\n        )\n        assert resp_login.status_code == 200, f\"Login failed: {resp_login.text}\"\n        if \"token\" in resp_login.json():\n            token = resp_login.json()[\"token\"]\n            session.headers.update({\"Authorization\": f\"Bearer {token}\"})\n\n        # Step 2: Upload a sample valid video/audio file for processing\n        # Using a small silent audio sample as binary content (simulate upload)\n        audio_content = b\"\\x52\\x49\\x46\\x46\\x24\\x08\\x00\\x00\\x57\\x41\\x56\\x45\\x66\\x6D\\x74\\x20\"  # small WAV header snippet\n\n        files = {\n            \"file\": (\"test_audio.wav\", audio_content, \"audio/wav\")\n        }\n        resp_upload = session.post(f\"{BASE_URL}/upload\", files=files, timeout=TIMEOUT)\n        assert resp_upload.status_code == 200, f\"Upload failed: {resp_upload.text}\"\n        upload_json = resp_upload.json()\n        assert \"file_id\" in upload_json or \"filename\" in upload_json, \"Upload response missing file identifier.\"\n\n        # Step 3: Test /process endpoint with valid parameters\n        # Verify various model_size and device enumeration options and edge cases\n        process_payload = {\n            \"spoken_lang\": \"en\",\n            \"target_lang\": \"es\",\n            \"model_size\": \"medium\",\n            \"device\": \"CPU\"\n        }\n        resp_process = session.post(f\"{BASE_URL}/process\", json=process_payload, timeout=TIMEOUT)\n        assert resp_process.status_code == 200, f\"Process endpoint failed: {resp_process.text}\"\n        process_result = resp_process.json()\n\n        # Validate keys and data structure in response\n        # Expect transcription text, translated text, subtitles info\n        assert \"transcription\" in process_result, \"Response missing 'transcription'.\"\n        assert isinstance(process_result[\"transcription\"], str), \"'transcription' should be string.\"\n        assert \"translation\" in process_result, \"Response missing 'translation'.\"\n        assert isinstance(process_result[\"translation\"], str), \"'translation' should be string.\"\n        assert \"subtitles\" in process_result, \"Response missing 'subtitles'.\"\n        assert isinstance(process_result[\"subtitles\"], list), \"'subtitles' should be a list.\"\n\n        for item in process_result[\"subtitles\"]:\n            assert isinstance(item, dict), \"Each subtitle should be a dict.\"\n            assert \"start\" in item and isinstance(item[\"start\"], (int, float)), \"'start' missing or invalid.\"\n            assert \"end\" in item and isinstance(item[\"end\"], (int, float)), \"'end' missing or invalid.\"\n            assert \"text\" in item and isinstance(item[\"text\"], str), \"'text' missing or invalid.\"\n\n        # Test edge cases: invalid model size\n        invalid_payload = dict(process_payload)\n        invalid_payload[\"model_size\"] = \"extra_large\"\n        resp_invalid = session.post(f\"{BASE_URL}/process\", json=invalid_payload, timeout=TIMEOUT)\n        assert resp_invalid.status_code in [400, 422], \"Invalid model_size should return client error.\"\n\n        # Test edge cases: invalid device\n        invalid_payload = dict(process_payload)\n        invalid_payload[\"device\"] = \"QuantumProcessor\"\n        resp_invalid = session.post(f\"{BASE_URL}/process\", json=invalid_payload, timeout=TIMEOUT)\n        assert resp_invalid.status_code in [400, 422], \"Invalid device should return client error.\"\n\n        # Test edge case: missing required fields\n        incomplete_payload = {\"spoken_lang\": \"en\"}\n        resp_incomplete = session.post(f\"{BASE_URL}/process\", json=incomplete_payload, timeout=TIMEOUT)\n        assert resp_incomplete.status_code in [400, 422], \"Missing fields should return client error.\"\n\n        # Test security: injection in spoken_lang\n        injection_payload = dict(process_payload)\n        injection_payload[\"spoken_lang\"] = \"'; DROP TABLE users; --\"\n        resp_inject = session.post(f\"{BASE_URL}/process\", json=injection_payload, timeout=TIMEOUT)\n        # Server should not execute injection but rather handle safely\n        assert resp_inject.status_code in [400, 422], \"Injection attempt should be rejected.\"\n\n        # Performance: basic timing check for process endpoint with normal params\n        start_time = time.time()\n        resp_perf = session.post(f\"{BASE_URL}/process\", json=process_payload, timeout=TIMEOUT)\n        duration = time.time() - start_time\n        assert resp_perf.status_code == 200, f\"Performance test process failed: {resp_perf.text}\"\n        # Check duration is reasonable (e.g., less than 60 seconds for medium model)\n        assert duration < 60, f\"Processing took too long: {duration} seconds\"\n\n    finally:\n        # Cleanup: delete user to clear test data if delete user endpoint available\n        del_resp = session.delete(f\"{BASE_URL}/db/users\", json={\"username\": user_data[\"username\"]}, timeout=TIMEOUT)\n        # Do not fail test on cleanup failure, but log if needed\n        if del_resp.status_code not in [200, 204, 404]:\n            print(f\"Warning: could not delete test user, status {del_resp.status_code}\")\n\ntest_process_video_audio_for_subtitle_generation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 122, in <module>\n  File \"<string>\", line 28, in test_process_video_audio_for_subtitle_generation\nAssertionError: Signup failed: <html><title>403: Forbidden</title><body>403: Forbidden</body></html>\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T15:23:09.176Z",
    "modified": "2025-09-06T15:24:03.749Z"
  },
  {
    "projectId": "a4172931-bb4c-4e43-b2cf-c045895728b2",
    "testId": "d014dd34-7511-44f8-be48-8b9c3eecc7d7",
    "userId": "f4783428-d071-70f8-dd6c-d4ad731b78ab",
    "title": "TC006-translate text segments to target language",
    "description": "Test the /translate endpoint by sending an array of text segments with start and end times along with a target_lang to verify accurate translation of text segments using Google Translate API.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8501\"\nTIMEOUT = 30\n\ndef test_translate_text_segments_to_target_language():\n    url = f\"{BASE_URL}/translate\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Define diverse segments including edge cases: empty text, overlapping times, long text, invalid times\n    segments = [\n        {\"start\": 0.0, \"end\": 2.5, \"text\": \"Hello world!\"},\n        {\"start\": 2.5, \"end\": 5.0, \"text\": \"This is a test.\"},\n        {\"start\": 5.0, \"end\": 5.0, \"text\": \"\"},  # zero length segment with empty text\n        {\"start\": 5.0, \"end\": 4.0, \"text\": \"Backwards time segment\"},  # invalid time range\n        {\"start\": 5.0, \"end\": 6.0, \"text\": \"Line with special chars: !@#$%^&*()\"},\n        {\"start\": 6.0, \"end\": 8.0, \"text\": \"Line with a very very very very very very very very very very very very long text segment to test performance and stability.\"},\n        {\"start\": 7.5, \"end\": 9.0, \"text\": \"Overlapping segment test.\"}\n    ]\n    target_lang = \"es\"  # Spanish\n\n    payload = {\n        \"segments\": segments,\n        \"target_lang\": target_lang\n    }\n\n    try:\n        start_time = time.time()\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        duration = time.time() - start_time\n    except requests.exceptions.Timeout:\n        assert False, \"Request timed out\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request exception occurred: {e}\"\n\n    # Basic response validations\n    assert response.status_code == 200, f\"Expected status 200 OK but got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate that response has translated segments, and lengths match\n    assert isinstance(data, dict), \"Response JSON should be a dictionary\"\n    assert \"segments\" in data, \"Response JSON missing 'segments' key\"\n    translated_segments = data[\"segments\"]\n    assert isinstance(translated_segments, list), \"'segments' should be a list\"\n    assert len(translated_segments) == len(segments), \"Number of translated segments does not match request\"\n\n    # Validate each segment structure and type\n    for original, translated in zip(segments, translated_segments):\n        assert isinstance(translated, dict), \"Each translated segment must be a dict\"\n        assert \"start\" in translated and \"end\" in translated and \"text\" in translated, \\\n            \"Translated segment missing required keys 'start', 'end', or 'text'\"\n        # Validate times match input for non-error segments (e.g. ignoring invalid time segment input)\n        if original[\"start\"] <= original[\"end\"]:\n            assert translated[\"start\"] == original[\"start\"], \"Translated segment 'start' time mismatch\"\n            assert translated[\"end\"] == original[\"end\"], \"Translated segment 'end' time mismatch\"\n        # Validate translated text is string and not empty if original text was not empty\n        assert isinstance(translated[\"text\"], str), \"Translated 'text' must be a string\"\n        if original[\"text\"].strip():\n            # Translation should produce some changed text, not empty and different if possible\n            assert translated[\"text\"].strip(), \"Translated text is empty for non-empty original\"\n            if translated[\"text\"].strip().lower() == original[\"text\"].strip().lower():\n                # Allowed that sometimes translation returns same text (e.g. proper nouns), so no assert fail\n                pass\n\n    # Performance check: response should be reasonably fast (e.g. under 5 seconds for this test)\n    assert duration < 10, f\"Translation took too long: {duration:.2f} seconds\"\n\n    # Test error handling for invalid input: missing target_lang\n    invalid_payloads = [\n        # Missing segments key\n        {\"target_lang\": \"fr\"},\n        # Missing target_lang key\n        {\"segments\": [{\"start\": 0, \"end\": 1, \"text\": \"Test\"}]},\n        # Empty segments array\n        {\"segments\": [], \"target_lang\": \"fr\"},\n        # Invalid segment data types\n        {\"segments\": [{\"start\": \"zero\", \"end\": \"one\", \"text\": 123}], \"target_lang\": \"fr\"},\n        # Unsupported target language code (assuming 'xx' invalid)\n        {\"segments\": [{\"start\": 0, \"end\": 1, \"text\": \"Hello\"}], \"target_lang\": \"xx\"}\n    ]\n\n    for invalid_payload in invalid_payloads:\n        try:\n            resp = requests.post(url, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n        except requests.exceptions.RequestException as e:\n            assert False, f\"Request exception with invalid payload: {e}\"\n        # Expect a 4xx error for invalid requests\n        assert resp.status_code >= 400 and resp.status_code < 500, \\\n            f\"Invalid payload should return client error but got status {resp.status_code}\"\n\n    # Security header checks: no unexpected sensitive headers exposed\n    for header_name in response.headers:\n        # For production, sensitive headers like 'Set-Cookie' or 'Server' should be checked if included\n        # Just ensure X-Frame-Options or Content-Security-Policy present for security best practices\n        pass\n\n    # Additional edge case: large number of segments\n    large_segments = [{\"start\": i*1.0, \"end\": i*1.0+0.5, \"text\": f\"Segment {i}\"} for i in range(1000)]\n    large_payload = {\n        \"segments\": large_segments,\n        \"target_lang\": \"de\"\n    }\n    try:\n        r_large = requests.post(url, json=large_payload, headers=headers, timeout=TIMEOUT)\n        assert r_large.status_code == 200, f\"Large payload translation failed with status {r_large.status_code}\"\n        data_large = r_large.json()\n        assert len(data_large.get(\"segments\", [])) == 1000, \"Large payload translation segment count mismatch\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request exception with large payload: {e}\"\n\ntest_translate_text_segments_to_target_language()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 117, in <module>\n  File \"<string>\", line 40, in test_translate_text_segments_to_target_language\nAssertionError: Expected status 200 OK but got 403\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T15:23:09.180Z",
    "modified": "2025-09-06T15:24:37.062Z"
  },
  {
    "projectId": "a4172931-bb4c-4e43-b2cf-c045895728b2",
    "testId": "af7afe55-5ae9-44e7-a786-9550433889e5",
    "userId": "f4783428-d071-70f8-dd6c-d4ad731b78ab",
    "title": "TC007-render subtitles on video with font and timing",
    "description": "Test the /render_subtitles endpoint by providing video_path, subtitle segments, output_path, and font_path to verify correct rendering of subtitles on the video with proper font selection and synchronization.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8501\"\nTIMEOUT = 30\n\ndef test_render_subtitles_on_video_with_font_and_timing():\n    \"\"\"\n    Test the /render_subtitles endpoint by providing video_path, subtitle segments,\n    output_path, and font_path to verify correct rendering of subtitles on the video\n    with proper font selection and synchronization.\n    \"\"\"\n\n    # For the test, we need a video_path and font_path.\n    # If not available, upload/create a minimal dummy video and font file.\n    # We'll simulate this by uploading a dummy video and using a dummy font.\n    # After the test, clean up created files.\n\n    session = requests.Session()\n\n    # Upload a dummy video file for testing\n    video_filename = \"test_video.mp4\"\n    font_filename = \"test_font.ttf\"\n    output_filename = \"output_test_video.mp4\"\n\n    try:\n        # Step 1: Upload Video File\n        video_file_content = (\n            b\"\\x00\\x00\\x00\\x18ftypmp42\\x00\\x00\\x00\\x00mp42mp41\"  # minimal mp4 header bytes for test\n        )\n        files = {\n            'file': (video_filename, video_file_content, 'video/mp4')\n        }\n        upload_response = session.post(f\"{BASE_URL}/upload\", files=files, timeout=TIMEOUT)\n        assert upload_response.status_code == 200, f\"Video upload failed: {upload_response.text}\"\n        upload_json = upload_response.json()\n        # Expecting a response with stored video path or identifier, fallback to filename\n        stored_video_path = upload_json.get(\"file_path\") or video_filename\n        assert stored_video_path, \"Uploaded video path missing in response.\"\n\n        # Step 2: Upload Font File (simulate by upload or external font path)\n        # Assuming font files can be uploaded via same /upload endpoint or available on server\n        # Here we simulate upload of a font file as well.\n        font_file_content = (\n            b\"\\x00\\x01\\x00\\x00\\x00\\x0f\\x00\\x80\\x00\\x03\\x00\\x50\\x47\\x46\\x20\\x20\"  # minimal ttf header bytes for test\n        )\n        files = {\n            'file': (font_filename, font_file_content, 'font/ttf')\n        }\n        font_upload_response = session.post(f\"{BASE_URL}/upload\", files=files, timeout=TIMEOUT)\n        if font_upload_response.status_code == 200:\n            font_json = font_upload_response.json()\n            stored_font_path = font_json.get(\"file_path\") or font_filename\n        else:\n            # If upload not supported for fonts, fallback to a default font path\n            stored_font_path = \"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\"\n\n        # Step 3: Prepare subtitle segments (edge and normal cases)\n        segments = [\n            {\"start\": 0.0, \"end\": 2.0, \"text\": \"Hello world!\"},\n            {\"start\": 1.5, \"end\": 4.0, \"text\": \"Overlapping subtitle\"},   # Overlapping time segment edge case\n            {\"start\": 5.0, \"end\": 5.5, \"text\": \"\"},                      # Empty text edge case\n            {\"start\": 6.0, \"end\": 6.5, \"text\": \"Quick subtitle\"},\n            # Extreme long subtitle text edge case\n            {\"start\": 7.0, \"end\": 10.0, \"text\": \"A\"*1000}\n        ]\n\n        payload = {\n            \"video_path\": stored_video_path,\n            \"segments\": segments,\n            \"output_path\": output_filename,\n            \"font_path\": stored_font_path\n        }\n\n        headers = {\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Step 4: Post to /render_subtitles endpoint\n        render_response = session.post(\n            f\"{BASE_URL}/render_subtitles\",\n            json=payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert render_response.status_code == 200, f\"Rendering subtitles failed: {render_response.text}\"\n        render_json = render_response.json()\n\n        # Step 5: Validate response content\n        # Expect some confirmation, e.g. output file path or success flag\n        assert \"output_path\" in render_json, \"output_path missing in response\"\n        assert render_json[\"output_path\"] == output_filename or render_json[\"output_path\"].endswith(output_filename), \"Output path mismatch\"\n\n        # Step 6: Security checks - basic validation to avoid injection or unsafe payload acceptance\n        # Since we control payload, we verify API returned expected results without errors.\n        # Check no error key in response and reasonable response time (basic performance check)\n        assert \"error\" not in render_json, \"API returned error in rendering subtitles\"\n\n        # Optional small performance benchmark (response time under timeout, ideally under 10s for this small test)\n        # Not an assert but print for observation\n        # print(f\"Render response time: {render_response.elapsed.total_seconds():.2f}s\")\n\n    finally:\n        # Cleanup uploaded files to avoid resource leak if API supports delete\n\n        # Attempt to delete test video file from server if such endpoint existed\n        # No delete endpoint given, so skip actual deletions.\n\n        # If files persisted locally, in real environment delete them here.\n        pass\n\n\ntest_render_subtitles_on_video_with_font_and_timing()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 113, in <module>\n  File \"<string>\", line 35, in test_render_subtitles_on_video_with_font_and_timing\nAssertionError: Video upload failed: <html><title>403: Forbidden</title><body>403: Forbidden</body></html>\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T15:23:09.185Z",
    "modified": "2025-09-06T15:24:08.297Z"
  },
  {
    "projectId": "a4172931-bb4c-4e43-b2cf-c045895728b2",
    "testId": "8ee80768-bf1e-4cc3-9783-1ce7a14b5c4e",
    "userId": "f4783428-d071-70f8-dd6c-d4ad731b78ab",
    "title": "TC008-download subtitle file by filename",
    "description": "Test the /download/srt endpoint by requesting a subtitle file with a valid filename query parameter to ensure the correct subtitle file is returned for download.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:8501\"\nDOWNLOAD_ENDPOINT = f\"{BASE_URL}/download/srt\"\nUPLOAD_ENDPOINT = f\"{BASE_URL}/upload\"\n\nTIMEOUT = 30\n\ndef test_download_subtitle_by_filename():\n    # Generate a unique filename for the test subtitle file\n    test_filename = f\"test_subtitle_{uuid.uuid4().hex}.srt\"\n    test_file_content = \"\"\"1\n00:00:00,000 --> 00:00:01,000\nHello world!\n\n\"\"\"\n\n    # Step 1: Upload a subtitle file to be downloaded\n    # Since the API does not explicitly provide a direct subtitle upload endpoint,\n    # upload a dummy video/audio file, then simulate subtitle generation by uploading the subtitle file separately.\n    # Assuming upload accepts any file for the demo purpose in this test.\n\n    # Create a dummy text file to upload as subtitle (simulate upload file)\n    try:\n        files = {\n            'file': (test_filename, test_file_content, 'application/x-subrip')\n        }\n        upload_response = requests.post(UPLOAD_ENDPOINT, files=files, timeout=TIMEOUT)\n        upload_response.raise_for_status()\n        # Assuming the upload returns JSON with confirmation or file id - but no schema given\n        # So, proceed assuming success means file stored for download\n\n        # Step 2: Test downloading the subtitle file by filename\n        params = {'filename': test_filename}\n        download_response = requests.get(DOWNLOAD_ENDPOINT, params=params, timeout=TIMEOUT)\n        # Response should be 200 and content is subtitle file\n        assert download_response.status_code == 200, f\"Expected 200 OK, got {download_response.status_code}\"\n        content_type = download_response.headers.get('Content-Type', '')\n        # SRT content-type typical is 'application/x-subrip' or 'text/plain'\n        assert content_type in ['application/x-subrip', 'text/plain', 'application/octet-stream'], f\"Unexpected Content-Type: {content_type}\"\n        content_disposition = download_response.headers.get('Content-Disposition', '')\n        assert test_filename in content_disposition, f\"Filename {test_filename} not in Content-Disposition header\"\n\n        content = download_response.content.decode('utf-8')\n        assert \"Hello world!\" in content, \"Downloaded subtitle content does not contain expected text\"\n\n        # Edge case: filename with special characters\n        special_filename = f\"test_subtitle_äöü_{uuid.uuid4().hex}.srt\"\n        files_special = {\n            'file': (special_filename, test_file_content, 'application/x-subrip')\n        }\n        upload_special_resp = requests.post(UPLOAD_ENDPOINT, files=files_special, timeout=TIMEOUT)\n        upload_special_resp.raise_for_status()\n        params_special = {'filename': special_filename}\n        download_special_resp = requests.get(DOWNLOAD_ENDPOINT, params=params_special, timeout=TIMEOUT)\n        assert download_special_resp.status_code == 200, f\"Expected 200 OK for special filename, got {download_special_resp.status_code}\"\n        assert special_filename in download_special_resp.headers.get('Content-Disposition', ''), \"Filename with special chars missing in header\"\n        assert \"Hello world!\" in download_special_resp.content.decode('utf-8'), \"Subtitle content mismatch for special filename\"\n\n        # Negative test: missing filename parameter\n        err_resp = requests.get(DOWNLOAD_ENDPOINT, timeout=TIMEOUT)\n        assert err_resp.status_code in [400, 422], f\"Expected 400 or 422 for missing filename, got {err_resp.status_code}\"\n\n        # Negative test: filename does not exist\n        params_nonexistent = {'filename': 'nonexistent_file_1234567890.srt'}\n        not_found_resp = requests.get(DOWNLOAD_ENDPOINT, params=params_nonexistent, timeout=TIMEOUT)\n        # Assuming 404 or 400 if not found\n        assert not_found_resp.status_code in [404, 400], f\"Expected 404 or 400 for nonexistent filename, got {not_found_resp.status_code}\"\n\n        # Security test: Path traversal attempt\n        dangerous_filename = \"../../etc/passwd\"\n        params_danger = {'filename': dangerous_filename}\n        danger_resp = requests.get(DOWNLOAD_ENDPOINT, params=params_danger, timeout=TIMEOUT)\n        # Should reject or sanitize the filename\n        assert danger_resp.status_code in [400, 403, 404], f\"Expected 400/403/404 for path traversal attempt, got {danger_resp.status_code}\"\n\n        # Performance: Measure response time for valid request\n        start_time = time.time()\n        perf_resp = requests.get(DOWNLOAD_ENDPOINT, params=params, timeout=TIMEOUT)\n        duration = time.time() - start_time\n        assert perf_resp.status_code == 200, f\"Performance test: Expected 200 OK, got {perf_resp.status_code}\"\n        assert duration < 5, f\"Performance test: Download took too long {duration:.2f} seconds\"\n\n    finally:\n        # Cleanup: If API had a delete or cleanup endpoint, call it here to remove test files\n        # No such endpoint defined in PRD for deleting individual files\n        # So cannot clean up uploaded test files via API - would require DB cleanup outside this test\n        pass\n\n\ntest_download_subtitle_by_filename()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 93, in <module>\n  File \"<string>\", line 31, in test_download_subtitle_by_filename\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 403 Client Error: Forbidden for url: http://localhost:8501/upload\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T15:23:09.189Z",
    "modified": "2025-09-06T15:24:16.289Z"
  },
  {
    "projectId": "a4172931-bb4c-4e43-b2cf-c045895728b2",
    "testId": "be42f1ce-50ba-4380-a8e5-35c19bf6faf6",
    "userId": "f4783428-d071-70f8-dd6c-d4ad731b78ab",
    "title": "TC009-download video file by filename",
    "description": "Test the /download/video endpoint by requesting a video file with a valid filename query parameter to verify the correct video file is returned for download.",
    "code": "import requests\nimport os\nimport time\n\nBASE_URL = \"http://localhost:8501\"\nTIMEOUT = 30\n\ndef test_download_video_file_by_filename():\n    # Preparations: upload a small dummy video file to have a file to download\n    upload_url = f\"{BASE_URL}/upload\"\n    download_url = f\"{BASE_URL}/download/video\"\n\n    # Create a small dummy video file (1 second, black frame) for test\n    dummy_video_path = \"test_dummy_video.mp4\"\n    downloaded_path = \"downloaded_test_dummy_video.mp4\"\n    try:\n        # Generate dummy video file using ffmpeg if available\n        if not os.path.exists(dummy_video_path):\n            import subprocess\n            try:\n                subprocess.run([\"ffmpeg\", \"-version\"], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n                cmd = [\n                    \"ffmpeg\", \"-y\", \"-f\", \"lavfi\", \"-i\", \"color=c=black:s=320x240:d=1\", \n                    \"-pix_fmt\", \"yuv420p\", dummy_video_path\n                ]\n                subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            except (subprocess.CalledProcessError, FileNotFoundError):\n                # ffmpeg not available; create small dummy binary file instead\n                with open(dummy_video_path, \"wb\") as f:\n                    f.write(b\"\\x00\" * 1024)  # 1KB dummy content\n\n        with open(dummy_video_path, \"rb\") as f:\n            files = {'file': (\"test_dummy_video.mp4\", f, \"video/mp4\")}\n            r_upload = requests.post(upload_url, files=files, timeout=TIMEOUT)\n        assert r_upload.status_code == 200, f\"Upload failed with status {r_upload.status_code}\"\n        \n        # Extract filename from upload response if provided, else use original filename\n        filename = None\n        try:\n            if r_upload.headers.get('Content-Type','').startswith('application/json'):\n                resp_json = r_upload.json()\n                # Look for 'filename' or similar in response to get stored filename\n                if 'filename' in resp_json:\n                    filename = resp_json['filename']\n                elif 'file_name' in resp_json:\n                    filename = resp_json['file_name']\n        except Exception:\n            pass\n        if not filename:\n            filename = \"test_dummy_video.mp4\"\n\n        # Wait briefly in case file processing/storage is async\n        time.sleep(1)\n\n        # Test: Download the video file by filename\n        params = {'filename': filename}\n        r_download = requests.get(download_url, params=params, timeout=TIMEOUT)\n        \n        # Successful response checks\n        assert r_download.status_code == 200, f\"Download failed with status {r_download.status_code}\"\n        content_type = r_download.headers.get('Content-Type', '')\n        assert 'video' in content_type, f\"Expected video content-type, got {content_type}\"\n        content_disp = r_download.headers.get('Content-Disposition', '')\n        assert filename in content_disp or filename in r_download.url, \"Filename not found in Content-Disposition or URL\"\n\n        # Check content length reasonable (>0 and matches uploaded file size roughly)\n        content_length = r_download.headers.get('Content-Length')\n        if content_length is not None:\n            size = int(content_length)\n            assert size > 0, \"Downloaded content length is zero\"\n            uploaded_file_size = os.path.getsize(dummy_video_path)\n            # Allow some tolerance for any compression or metadata changes\n            assert abs(size - uploaded_file_size) < uploaded_file_size * 0.5, \\\n                f\"Downloaded file size {size} differs significantly from uploaded size {uploaded_file_size}\"\n\n        # Try saving downloaded content to verify file is valid video format\n        with open(downloaded_path, \"wb\") as f:\n            f.write(r_download.content)\n\n        # Quick validation: check if downloaded file size > 0 and is non-empty\n        assert os.path.getsize(downloaded_path) > 0, \"Downloaded video file is empty\"\n\n        # Optionally, run ffprobe or similar to verify video file integrity (if ffprobe installed)\n        try:\n            import subprocess\n            probe = subprocess.run(\n                [\"ffprobe\", \"-v\", \"error\", downloaded_path],\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE\n            )\n            assert probe.returncode == 0, f\"Downloaded file failed ffprobe check: {probe.stderr.decode()}\"\n        except FileNotFoundError:\n            # ffprobe not installed, skip this validation\n            pass\n\n    finally:\n        # Cleanup: delete uploaded file if API exists, and remove local files\n        # No delete endpoint provided in PRD for uploaded files, so just remove local files\n        for fpath in [dummy_video_path, downloaded_path]:\n            try:\n                if os.path.exists(fpath):\n                    os.remove(fpath)\n            except Exception:\n                pass\n\ntest_download_video_file_by_filename()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 21, in test_download_video_file_by_filename\n  File \"/var/lang/lib/python3.12/subprocess.py\", line 548, in run\n    with Popen(*popenargs, **kwargs) as process:\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/subprocess.py\", line 1026, in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n  File \"/var/lang/lib/python3.12/subprocess.py\", line 1955, in _execute_child\n    raise child_exception_type(errno_num, err_msg, err_filename)\nFileNotFoundError: [Errno 2] No such file or directory: 'ffmpeg'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 105, in <module>\n  File \"<string>\", line 29, in test_download_video_file_by_filename\nOSError: [Errno 30] Read-only file system: 'test_dummy_video.mp4'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T15:23:09.194Z",
    "modified": "2025-09-06T15:24:40.814Z"
  },
  {
    "projectId": "a4172931-bb4c-4e43-b2cf-c045895728b2",
    "testId": "f4fd2c94-2b1e-4997-85c4-383e6968d460",
    "userId": "f4783428-d071-70f8-dd6c-d4ad731b78ab",
    "title": "TC010-admin get all users with optional search",
    "description": "Test the /admin/users endpoint with and without the optional search query parameter to verify retrieval of user list filtered by search criteria if provided.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8501\"\nADMIN_USERS_ENDPOINT = f\"{BASE_URL}/admin/users\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/login\"\nSIGNUP_ENDPOINT = f\"{BASE_URL}/signup\"\nDELETE_USER_ENDPOINT = f\"{BASE_URL}/admin/users/{{username}}\"\n\n# Credentials for a test admin user (adjust accordingly or create dynamically)\nADMIN_CREDENTIALS = {\n    \"username\": \"testadminuser\",\n    \"password\": \"AdminPass123!\"\n}\n\ndef create_test_admin_user():\n    # Try to create a test admin user for authentication, ignore if exists\n    signup_payload = {\n        \"full_name\": \"Test Admin\",\n        \"email\": \"testadmin@example.com\",\n        \"username\": ADMIN_CREDENTIALS[\"username\"],\n        \"password\": ADMIN_CREDENTIALS[\"password\"]\n    }\n    try:\n        resp = requests.post(SIGNUP_ENDPOINT, json=signup_payload, timeout=30)\n        # 201 Created or 409 Conflict (user exists) acceptable\n        if resp.status_code not in [201, 409]:\n            resp.raise_for_status()\n    except Exception as e:\n        # Log or pass if user already exists for test continuity\n        pass\n\ndef login_admin():\n    resp = requests.post(LOGIN_ENDPOINT, json=ADMIN_CREDENTIALS, timeout=30)\n    resp.raise_for_status()\n    token = resp.json().get(\"access_token\") or resp.json().get(\"token\")  # token key depends on implementation\n    if not token:\n        raise RuntimeError(\"Admin login failed: no token returned\")\n    return token\n\ndef delete_test_admin_user(username, headers):\n    # Clean up test user if needed\n    url = DELETE_USER_ENDPOINT.format(username=username)\n    try:\n        resp = requests.delete(url, headers=headers, timeout=30)\n        if resp.status_code not in (200, 204, 404):\n            resp.raise_for_status()\n    except Exception:\n        pass  # best effort cleanup\n\ndef test_admin_get_all_users_with_optional_search():\n    create_test_admin_user()\n    token = login_admin()\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    try:\n        # 1. Test without search parameter (get all users)\n        resp = requests.get(ADMIN_USERS_ENDPOINT, headers=headers, timeout=30)\n        assert resp.status_code == 200, f\"Expected 200 OK but got {resp.status_code}\"\n        users = resp.json()\n        assert isinstance(users, list), \"Response without search should be a list\"\n        usernames = {u.get(\"username\") for u in users if isinstance(u, dict) and \"username\" in u}\n        assert len(users) >= 1, \"User list should contain at least one user (admin user present)\"\n\n        # 2. Test with search parameter that matches a username partially\n        if usernames:\n            sample_username = next(iter(usernames))\n            # Take a substring to test partial search\n            search_query = sample_username[:3]\n            resp_search = requests.get(ADMIN_USERS_ENDPOINT, headers=headers, params={\"search\": search_query}, timeout=30)\n            assert resp_search.status_code == 200, f\"Expected 200 OK but got {resp_search.status_code} for search query\"\n            filtered_users = resp_search.json()\n            assert isinstance(filtered_users, list), \"Response with search should be a list\"\n            assert any(search_query.lower() in u.get(\"username\", \"\").lower() for u in filtered_users), \"Filtered users should contain search query\"\n\n            # Test empty list behavior for a search that unlikely matches\n            unlikely_search = \"no_such_user_1234567890\"\n            resp_none = requests.get(ADMIN_USERS_ENDPOINT, headers=headers, params={\"search\": unlikely_search}, timeout=30)\n            assert resp_none.status_code == 200, f\"Expected 200 OK but got {resp_none.status_code} for unlikely search\"\n            assert resp_none.json() == [], \"Search with no match should return empty list\"\n\n        # 3. Test input validation: search with special chars and unicode\n        special_searches = [\"!@#$%^&*()\", \"测试\", \"ユーザー\"]\n        for s in special_searches:\n            resp_special = requests.get(ADMIN_USERS_ENDPOINT, headers=headers, params={\"search\": s}, timeout=30)\n            assert resp_special.status_code == 200, f\"Expected 200 OK but got {resp_special.status_code} for special search {s}\"\n            assert isinstance(resp_special.json(), list), f\"Response for special search {s} should be a list\"\n\n        # 4. Test error handling: invalid auth token\n        bad_headers = {\"Authorization\": \"Bearer invalidtoken123\"}\n        resp_unauth = requests.get(ADMIN_USERS_ENDPOINT, headers=bad_headers, timeout=30)\n        assert resp_unauth.status_code in (401, 403), \"Invalid token should cause 401 Unauthorized or 403 Forbidden\"\n\n        # 5. Performance - measure response time for a request\n        start = time.time()\n        resp_perf = requests.get(ADMIN_USERS_ENDPOINT, headers=headers, timeout=30)\n        elapsed = time.time() - start\n        assert resp_perf.status_code == 200, \"Performance test request failed\"\n        assert elapsed < 5.0, f\"Response time {elapsed}s exceeds threshold for production\"\n    finally:\n        # No test user deletion here as admin user may be persistent\n        pass\n\n\ntest_admin_get_all_users_with_optional_search()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 105, in <module>\n  File \"<string>\", line 53, in test_admin_get_all_users_with_optional_search\n  File \"<string>\", line 35, in login_admin\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 403 Client Error: Forbidden for url: http://localhost:8501/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-06T15:23:09.199Z",
    "modified": "2025-09-06T15:24:15.686Z"
  }
]
